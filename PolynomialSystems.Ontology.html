<h3 id="polynomial-systems-ontology">Polynomial Systems Ontology</h3>
<p>An informal description of the Ontology of the Knowledge Base of Polynomial Systems and Ideals developed so far.</p>
<h4 id="metadata-and-semantics">Metadata and Semantics</h4>
<p>Different to earlier versions in the upcoming SymbolicData v.3 (scheduled for Aug 2013) we drastically reduced the number of really stored polynomial systems in favour of standardized polynomial time (in the input length) algorithms to generate derived examples by a well defined workflow described below.</p>
<p>We assume the user to have semantic aware tools at hand to generate the required examples and provide a prototypical solution for <a href="http://www.sagemath.org">Sage</a> that can easily adapted to your favourite CA system.</p>
<p>Develop the Sage solution. -- Assigned to Andreas.</p>
<p>We encourage users to share their code developed for other CAS.</p>
<p>The starting point are polynomial systems in XML notation and descriptions how to generate different ideals from that data. Polynomial systems in XML notation are stored in the XMLResources part as Integer Polynomial Systems (IntPS) or - a small number of examples - as Modular Polynomial Systems (ModPS). Metadata (including information about ideal generation) are stored in RDF form in the RDFData part that can be searched by <a href="QuickStart" title="wikilink">Sparql</a> queries.</p>
<p>A <strong>polynomial system</strong> XML file - integer or modular - provides a list of (case sensitive) variable names x_1,...,x_n and a list of polynomials p_1,...,p_m in distributive from in that variable names with integer coefficients (i.e., matching the regex [\\d+]) in a syntax that can be directly read in by most CAS. You need an XML parser to extract both parts and a parser for polynomials to read in the data and interpret it semantically as list of polynomials in the ring Z[x_1,...,x_n].</p>
<p>Polynomial Systems instances belong to the classes <strong>sd:IntegerPolynomialSystem</strong> or <strong>sd:ModularPolynomialSystem</strong> with predicates</p>
<ul>
<li>standard predicates sd:createdAt, sd:createdBy, rdfs:comment</li>
<li>sd:relatedXMLResource URL - the URL of the corresponding XML resource</li>
</ul>
<p>Due to the universal property of Z[x_1,...,x_n] such a polynomial list is the semantic starting point for all further constructions. There is a unique URI for each polynomial system in the RDF Data, e.g.,</p>
<p>symbolicdata.org/Data/IntPS/Wang-92c</p>
<p>for the polynomial system with the XML Resource</p>
<p>symbolicdata.org/XMLResources/IntPS/Wang-92c.xml</p>
<p>The polynomial system defines a <strong>flat ideal</strong> in the ring Q[x_1,...,x_n] that is referenced as</p>
<p>symbolicdata.org/Data/Ideal/Wang-92c</p>
<p>It is a special case of an entry point to the ideals dependency tree and has a predicate <em>sd:relatedPolynomialSystem</em> that refers to the underlying polynomial system.</p>
<p>A flat ideal does not have <em>sd:hasParameters</em> predicate.</p>
<p>All <strong>other ideals</strong> are derived along the <em>ideals dependency (oriented) tree</em> from already known ideals (parents) as <em>push forward images</em> or <em>inverse push forward images</em> of the generating polynomials of the known ideal along canonical ring homomorphisms by a restricted number of operations:</p>
<ul>
<li>interpreting part of the variables as parameters
<ul>
<li>sd:parameterize ParentIdealURI</li>
<li>sd:hasParameters ParameterList - comma separated list of variable names serving as parameters</li>
<li>sd:hasVariables VariableList - comma separated list of variable names serving as variables</li>
<li>The variable list of the parent is the disjoint uniion of ParameterList and VariableList</li>
</ul></li>
<li>homogenizing polynomials,
<ul>
<li>sd:homogenize ParentIdealURI</li>
<li>sd:homogenizedWith VarName</li>
</ul></li>
<li>flatten an ideal (inverse to parameterization)
<ul>
<li>sd:flatten ParentIdealURI</li>
</ul></li>
<li>substituting special values for variables.
<ul>
<li>not yet included.</li>
</ul></li>
</ul>
<p><strong>Aside:</strong> Given a ring homomorphism \\phi: R -&gt; S and ideals I\\subset R and J\\subset S the notion of pull back \\phi^{-1}(J) and push forward \\phi(I)*S of ideals are well known. On the level of generators we have to be more careful: Given a ring homomorphism \\phi: R -&gt; S the <em>push forward</em> ideal of I=(f_1,...,f_m) is generated by the pushed forward polynomials \\phi(f_1),...,\\phi(f_m). For the <em>inverse push forward image</em> we assume that \\phi is injective and the generators J=(g_1,...,g_m)\\subset S are in the image \\phi(R). Then there are unique elements g_i'\\in R such that \\phi(g_i')=g_i and J is the push forward ideal of I=(g_1',...,g_m')\\subset R. We call I the inverse push forward image. For homogenization as inverse push forward image the story is even a little more tricky, but we leave the details to the reader, since this does not affect the procedure (homogenization of given polynomials) itself. Note that I\\subset \\phi^{-1}(J) but \\phi^{-1}(J) can be much larger and hard to compute.</p>
<h4 id="identification">Identification</h4>
<p>A hard problem is to identify if a given external polynomial systems is contained in the data, since the same polynomial system is given in the literature with different variable names in different orders. Moreover, there are several &quot;almost equal&quot; examples, that came into life by missprints but started their own life afterwards.</p>
<p>To navigate within the examples we compute and store invariants of the generating polynomials and the ideals. For a given generating set we interpret the polynomials in the given ring in expanded distributive form, extract the list of terms, compute length lists and (total) degree lists and store them in (independently) ordered form as values of the predicates <em>sd:hasDegreeList</em> and <em>sd:hasLengthsList</em>.</p>
<p>Change sd:hasLengthsList to sd:hasLengthList ? -- HGG</p>
<p>These values are independent from the variable names used in different sources for the same example and allow to shrink the search space to identify if a given example is already contained in our collection.</p>
<h4 id="predicates-for-sdideal">Predicates for sd:Ideal</h4>
<p>Classes:</p>
<ul>
<li>sd:Ideal</li>
<li>sd:HomogeneousIdeal</li>
</ul>
<p>Predicates:</p>
<ul>
<li>sd:hasVariables Literal - comma separated list of variables</li>
<li>sd:hasParameters Literal - comma separated list of parameters</li>
<li>sd:hasDegreeList - comma separated list of integers in increasing order, degrees of the generating polynomials
<ul>
<li>order has to be fixed</li>
</ul></li>
<li>sd:hasLengthsList - comma separated list of integers in increasing order, number of terms of the generating polynomials
<ul>
<li>order has to be fixed</li>
</ul></li>
</ul>
<p>Invariants of the ideal</p>
<ul>
<li>sd:hasDegree Literal - integer, degree for a zerodimensional ideal</li>
<li>sd:hasDimension Literal - integer, dimension for an ideal</li>
<li>sd:hasIsolatedPrimesDegrees Literal - comma separated list of integers, degrees of the prime components of a zero dimensional ideal</li>
<li>sd:hasIsolatedPrimesDimensions Literal - comma separated list of integers, dimensions of the isolated prime components</li>
</ul>
<h4 id="polynomial-systems-xml-resources">Polynomial Systems XML-Resources</h4>
<p>The XML-Resource contains mainly the following tags</p>
<ul>
<li>(ModPS only) <basedomain> - the base domain (if not the rationals)</li>
<li><vars> - a list x1,...,xn of variables,</li>
<li><basis> - a sequence of <poly> entries of (commutative) polynomials</li>
</ul>
<p>For details see the XSchema description <a href="http://symbolicdata.org/XMLResources/PolynomialSystem.xsd">PolynomialSystem.xsd</a>.</p>
<h4 id="changes">Changes</h4>
<ul>
<li>Change URIs in the following way:
<ul>
<li>Convert existing examples from type sd:IntPS to sd:Ideal, change URI to symbolicdata.org/Data/Ideal/... -- 2013-0717 HGG, done</li>
<li>Add new entries of type sd:IntegerPolynomialSystem resp. sd:ModularPolynomialSystem to refer to the Polynomial Systems XML resources -- 2013-0717 HGG, done</li>
</ul></li>
<li>Fix LengthsLists and DegreeLists according to the correct semantic interpretation of the polynomials (in distributive normal form) in the underlying polynomial ring - extract the correct lists of terms, compute their lengths and max. total degrees and arrange that data in increasing order. (Andreas works on that - 2013-07-14)</li>
</ul>
