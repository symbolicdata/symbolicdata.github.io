<h2 id="polynomial-systems-and-sage">Polynomial Systems and Sage</h2>
<p>On this page we explain how a Computer Algebra System like Sage can be used to both enhance and process Linked Data. This serves as a blueprint of a possible method that can be applied to other Linked Mathematical Data. The content here is mostly written under a technical point of view that allows others to experiment with Sage. The sdsage script can be found in our <a href="https://github.com/hg-graebe/symbolicdata/tree/rc-1/src/sdsage">Github Repo</a>.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Obviously, Sage is required. It can be obtained from <a href="http://www.sagemath.org">http://www.sagemath.org</a>. Once downloaded and unzipped, it will be located in a folder $SAGE_ROOT. Sage comes with its own Python version. Scripts using the Sage libraries can be run with</p>
<p><code>./sage -python script.py</code></p>
<p>Another possibility is to install all the Sage modules into your running Python instance. We will not discuss this further here.</p>
<p>Additionally to Sage, the <a href="http://docs.python-requests.org/">requests library</a> is required, as this library is not installed by default and has to be installed for the Sage Python.</p>
<h5 id="installing-new-packages-into-sage-python">Installing New Packages Into Sage Python</h5>
<p>Installing new packages can easily be done by installing pip. This can be done by invoking a Sage sub-shell:</p>
<p><code>./sage -sh</code></p>
<p>Next, install pip for Sage Python:</p>
<p><strong><code>(sage-sh)</code></strong><code> easy_install pip</code></p>
<p>In the message that follows, there should be something like &quot;Installing pip script to $SAGE_ROOT/local/bin&quot;. New libraries can now be installed with pip. However, calling simply pip from the Sage sub-shell might not work (the 'normal' pip was called, not the Sage pip). In this case pip can be called by prefixing the correct path:</p>
<p><strong><code>(sage-sh)</code></strong><code> $SAGE_ROOT/local/bin/pip install requests</code></p>
<p>The Sage sub-shell can be exited by typing 'exit'.</p>
<h3 id="basic-usage">Basic Usage</h3>
<p>To use the sdsage.py module, it has to be imported into the running python instance of Sage:</p>
<p><strong><code>sage:</code></strong><code> import sdsage</code></p>
<p>The module has to be initialized by the command</p>
<p><strong><code>sage:</code></strong><code> sd = sdsage.SymbolicData()</code></p>
<p>which will parse the configuration file (sdsage.ini) and set-up variables. It is possible to use different SPARQL end-points by passing a keyword to the constructor:</p>
<p><strong><code>sage:</code></strong><code> sd = sdsage.SymbolicData('local')</code></p>
<p>Keywords are defined in the SPARQL section of the sdsage.ini file:</p>
<p><code>[sparql]</code> <code>symbolicdata.org = </code><a href="http://symbolicdata.org:8890/sparql"><code>http://symbolicdata.org:8890/sparql</code></a> <code>local = </code><a href="http://localhost:8890/sparql"><code>http://localhost:8890/sparql</code></a></p>
<p>By default, the SPARQL endpoint from symbolicdata.org will be used. Note that the local SPARQL endpoint will not be available unless you install a triple store on your own machine.</p>
<p>The SymbolicData object we created above has several methods:</p>
<ul>
<li><strong>list_ideals()</strong> displays all available ideal names on screen</li>
<li><strong>get_ideals()</strong> returns a list of ideal names that can be used in a script</li>
<li><strong>get_ideal(<name>)</strong> returns a Sage ideal objects which can be used like any other Sage ideal</li>
<li><strong>get_sd_ideal(<name>)</strong> returns an SD_Ideal object that represents the SymbolicData database object for this ideal</li>
</ul>
<p>The parameter <name> is a string that either can be a complete URI like <a href="http://symbolicdata.org/Data/Ideal/Buchberger-87.Homog">http://symbolicdata.org/Data/Ideal/Buchberger-87.Homog</a> or just 'Buchberger-87.Homog'. The SD_Ideal object will be discussed in greater detail in the next section. We end this section with a longer usage example:</p>
<p><strong><code>sage:</code></strong><code> import sdsage</code> <strong><code>sage:</code></strong><code> sd = sdsage.SymbolicData()</code> <strong><code>sage:</code></strong><code> sd.list_ideals()</code> <code>Curves.curve15_20.Generators              Buchberger-87.Homog</code> <code>Butcher                                   Cassou</code> <code>Cohn_2.Homog                              Curves.curve10_20.Generators</code> <em><more lines here></em> <strong><code>sage:</code></strong><code> bb87h = sd.get_ideal('Buchberger-87.Homog')</code> <strong><code>sage:</code></strong><code> bb87h</code> <code>Ideal (-r*t + x*hv, -r^2 + z*hv, -r*t^2 + y*hv^2) of Multivariate Polynomial Ring in r, t, x, y, z, hv over Integer Ring</code> <strong><code>sage:</code></strong><code> bb87h.groebner_basis()</code> <code>[t^2*z*hv - r*y*hv^2, x^2*hv^2 - r*y*hv^2, r*x*hv - t*z*hv, t*x*hv - y*hv^2, r^2 - z*hv, r*t - x*hv]</code> <strong><code>sage:</code></strong><code> sd_bb87h = sd.get_sd_ideal('Buchberger-87.Homog')</code> <strong><code>sage:</code></strong><code> sd_bb887</code> <sdsage.SD_Ideal instance at 0xc88902c></p>
<h3 id="the-sd_ideal-object">The SD_Ideal Object</h3>
<p>SD_Ideal objects represent a SymbolicData database object. The constructor takes a string which either is a complete URI or a simple name (the latter of which will be prefixed with the 'ideal' value from the sdsage.ini)</p>
<p>Any triple of the form (SUBJ, PRED, OBJ) will yield a field PRED* for the SD_Ideal object with the value OBJ, where PRED* is the ending piece of PRED , i.e. everything before and including the last / or # is thrown away.</p>
<p>Take for example Buchberger-87, the TTL for this Ideal looks like this:</p>
<p><a href="http://symbolicdata.org/Data/Ideal/Buchberger-87">http://symbolicdata.org/Data/Ideal/Buchberger-87</a> <code>    rdf:type sd:Ideal ;</code> <code>    sd:createdAt &quot;1999-03-26&quot; ;</code> <code>    sd:createdBy sdp:Graebe_HG ;</code> <code>    sd:hasDegreeList &quot;2,2,3&quot; ;</code> <code>    sd:hasDimension &quot;2&quot; ;</code> <code>    sd:hasLengthsList &quot;2,2,2&quot; ;</code> <code>    sd:hasVariables &quot;r,t,x,y,z&quot; ;</code> <code>    sd:relatedPolynomialSystem </code><a href="http://symbolicdata.org/Data/IntPS/Buchberger-87">http://symbolicdata.org/Data/IntPS/Buchberger-87</a><code> ;</code> <code>    rdfs:comment &quot;Origin: Implicitation of (r*t,r*t^2,r^2)&quot; .</code></p>
<p>Once loaded by</p>
<p><strong><code>sage:</code></strong><code> sd_bb87 = sd.get_sd_ideal('Buchberger-87')</code></p>
<p>these value can be accessed as follows:</p>
<p><strong><code>sage:</code></strong><code> sd_bb87.createdAt</code> <code>u'1999-03-26'</code> <strong><code>sage:</code></strong><code> sd_bb87.createdBy</code> <code>u'</code><a href="http://symbolicdata.org/Data/Person/Graebe_HG"><code>http://symbolicdata.org/Data/Person/Graebe_HG</code></a><code>'</code> <strong><code>sage:</code></strong><code> sd_bb87.type</code> <code>u'</code><a href="http://symbolicdata.org/Data/Model#Ideal"><code>http://symbolicdata.org/Data/Model#Ideal</code></a><code>'</code> <strong><code>sage:</code></strong><code> sd_bb87.hasLengthsList</code> <code>u'2,2,2'</code> <strong><code>sage:</code></strong><code> sd_bb87.relatedPolynomialSystem</code> <code>u'</code><a href="http://symbolicdata.org/Data/IntPS/Buchberger-87"><code>http://symbolicdata.org/Data/IntPS/Buchberger-87</code></a><code>' ;</code></p>
<p>Two things are to be noted:</p>
<ul>
<li>The returned value always is a unicode string, which is shown by the u before the first quote.</li>
<li>The returned value can also be a full URI that points to other resources. To further investigate resources that do not belown to the class sd:Ideal, other tools like the OntoWiki have to be used.</li>
</ul>
<p>Another important thing is, that the integer polynomial system <a href="http://symbolicdata.org/Data/IntPS/Buchberger-87">http://symbolicdata.org/Data/IntPS/Buchberger-87</a> is referenced. This is not always the case. We will discuss this in greater detail in the next section.</p>
<p>Of course the SD_Ideal objects are more than just an alternative representation of the TTL file. In the case of the Buchberger-87 ideal, also the data from the referenced integer polynomial system is loaded. Most importantly, the expressions that define the basis elements are loaded. With Sage, a Polynomial Ring is constructed (according to the information found in the TTL file) and the aforementioned expressions are interpreted as elements of this Polynomial Ring. These element will form a basis of the ideal and finally, the ideal can be recreated within Sage. Continuing our example from above, this Sage ideal can be retrieved by:</p>
<p><strong><code>sage:</code></strong><code> sd_bb87.get_ideal()</code> <code>Ideal (-r*t + x, -r^2 + z, -r*t^2 + y) of Multivariate Polynomial Ring in r, t, x, y, z over Integer Ring</code></p>
<p>A short-cut to this function is provided by the <strong>get_ideal()</strong> function of the SymbolicData object discussed in the previous section.</p>
<p>While some object values from the TTL are other URI that point to other resources, some values are just strings, like for example the LengthsList '2,2,2'. If we only look at the TTL this is the end of the line: no further information can be obtained apart from maybe a datatype. But the semantics (or the meaning) of '2,2,2' is missing. Of course, one can readily explain what the '2,2,2' actually stands for. However, we are looking for a 'formal meaning', something that can be processed by a computer or an algorithm.</p>
<p>So, for the mathematical metadata 'hasDegreeList' and 'hasLengthsList' we provide the Sage/Python functions</p>
<ul>
<li>sage_hasDegreeList()</li>
<li>sage_hasLengthsList()</li>
</ul>
<p>Not only does this allow to check the consistency of the data from the TTL, but it also enables us to calculate metadata for new ideals. In the same manner, additional (mathematical) properties can be defined by a Sage/Python function.</p>
<h3 id="ideal-reconstruction-in-detail">Ideal Reconstruction In Detail</h3>
<p>In the previous section we noted, that for Buchberger-87 there is a related Polynomial System, namely <a href="http://symbolicdata.org/Data/IntPS/Buchberger-87">http://symbolicdata.org/Data/IntPS/Buchberger-87</a>. If we look at other ideals, there often is no related Polynomial System. The question is, where the expressions to generated the ideal are to be found. There are four cases we have to deal with:</p>
<ul>
<li>the ideal is constructed direclty from an IntPS with related XML resource</li>
<li>the ideal is a flat variant of another ideal</li>
<li>the ideal is obtained by homogenizing another ideal</li>
<li>the ideal is obtained by parameterizing another ideal</li>
</ul>
<p>A more mathematical discussion of these possibilities can be found on the page [PolynomialSystems].</p>
<p>The corresponding predicates/properties are:</p>
<ul>
<li>sd:relatedPolynomialSystem</li>
<li>sd:flatten</li>
<li>sd:homogenize, sd:homogenizedWith</li>
<li>sd:parameterize</li>
</ul>
<p>Only the first case allows directy construction of the ideal. For all other cases a stack will be built recursively. For instance, for the ideal Czapor-86c.Flat.Homog the information</p>
<p><a href="http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat.Homog">http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat.Homog</a> <code>    sd:homogenizedWith &quot;hv&quot; ;</code> <code>    sd:homogenize </code><a href="http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat">http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat</a><code> .</code></p>
<p>shows, that at first the ideal Czapor-86c.Flat must be reconstructed (the naming also shows this, but this is just 'syntactic sugar'). So we try to reconstruct this one. We find the following information:</p>
<p><a href="http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat">http://symbolicdata.org/Data/Ideal/Czapor-86c.Flat</a> <code>    sd:relatedPolynomialSystem </code><a href="http://symbolicdata.org/Data/IntPS/Czapor-86c">http://symbolicdata.org/Data/IntPS/Czapor-86c</a><code> .</code></p>
<p>Since we arrived at an ideal with a related Polynomial System, reconstruction is possible and so also Czapor-86c.Flat.Homog can be reconstructed. We say that Czapor-86c.Flat provides a <em>flat entry point</em>. Note that the chain can also be longer, take for example Czapor-86c.Homog.Flat.Homog.</p>
<p>Along with the hasLengthsList and hasDegreeList from the previous section, we have again used Sage to define the meaning of these predicates by provided code that actually implements them.</p>
<h3 id="usage-in-other-scripts">Usage In Other Scripts</h3>
<p>sdsage can also be used as a module in other script. We give a brief example of how the LengthsList properties could be checked:</p>
<p><code>import sdsage</code> <code>sd = sdsage.SymbolicData()</code> <code>for ideal in sd.get_ideals():</code> <code>    sd_ideal = sd.get_sd_ideal(ideal)</code> <code>    print &quot;Now checking: %s&quot; % ideal;</code> <code>    if sd_ideal.hasLengthsList != sd_ideal.sage_hasLengthsList():</code> <code>        print &quot;    &gt; LengthsList need to be checked&quot;</code> <code>        print &quot;    TTL : %s&quot; % sd_ideal.hasLengthList</code> <code>        print &quot;    Sage: %s&quot; % sd_ideal.FROM_SAGE_hasLengthsList</code></p>
<p>For symmetry reasons, once sage_hasLengthsList() has calculated the LengthsList, it can be obtained as a field FROM_SAGE_hasLengthsList (rather than calling a function).</p>
<h3 id="outlook">Outlook</h3>
<p>Right now sdsage only provides methods to import data from SymbolicData into Sage. The next step would be to allow updates of the data of the triple store directly from a script. One ad-hoc possiblity is to do this by using the isql which Virtuoso provides by simply piping a string to it as described here: <a href="http://symbolicdata.org/wiki/LocalSparqlEndpoint#Data_Management">LocalSparqlEndpoint#Data_Management</a></p>
